I"O
<h1 id="java-jvm">Java jvm</h1>

<h3 id="jvm은-java와-os사이에서-중개자-역할을-하며-java가-os에-구애받지-않고-재사용을-가능하게">jvm은 java와 os사이에서 중개자 역할을 하며 java가 os에 구애받지 않고 재사용을 가능하게</h3>
<h3 id="해준다-그리고-메모리관리-gc를-수행한다">해준다. 그리고 메모리관리, GC를 수행한다.</h3>
<h3 id="그리고-jvm은-스택기반이다">그리고 jvm은 스택기반이다.</h3>

<p><br /></p>

<h2 id="자바프로그램-실행과정">자바프로그램 실행과정</h2>
<blockquote>
  <ol>
    <li>프로그램이 실행되면 JVM은 OS로부터 이 프로그램이 필요로 하는 메모리를 할당 받는다.
JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.</li>
    <li>자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어 자바 바이트코드(.class)로 변환</li>
    <li>Class Loader를 통해 class파일들을 JVM으로 로딩한다.</li>
    <li>로딩된 class파일들은 Execution engine을 통해 해석된다.(로딩된 바이트 코드-&gt;바이너리 코드로 변경)</li>
    <li>해석된 바이트 코드는 Runtime Data Area에 배치되어 실질적인 수행이 이루어지게 된다.
이러한 실행 과정 속에서 JVM은 필요에 따라 Thread Synchronization과 GC같은 작업을 한다.</li>
  </ol>
</blockquote>

<p><br /></p>

<h2 id="jvm-구성">jvm 구성</h2>

<ol>
  <li>
    <h3 id="java-complier-java-소스-파일을-jvm이-해석할-수-있는-java-byte-codeclass파일">Java Complier: java 소스 파일을 jvm이 해석할 수 있는 Java Byte Code(.class파일)</h3>
    <p>로 변경한다. 일반적인 윈도우 프로그램에서는 컴파일이후 어셈블리 파일이 생성된다.</p>
  </li>
  <li>
    <h3 id="class-loader-jvm으로-class파일들을-load한다-loading된-클래스들은">Class Loader: JVM으로 .class파일들을 Load한다. Loading된 클래스들은</h3>
    <p>Runtime data area에 배치된다. 일반적인 윈도우 프로그램의 경우 Load는 os가 주도</p>
  </li>
  <li>
    <h3 id="execution-engine-loading된-클래스의-bytecode를-해석interpret한다-이-과정에서">Execution Engine: Loading된 클래스의 Bytecode를 해석(Interpret)한다. 이 과정에서</h3>
    <p>Bytecode가 Binary Code로 변경된다.</p>
  </li>
  <li>
    <h3 id="runtime-data-area-jvm이라는-프로그램이-os로부터-할당-받는-메모리-영역이다">Runtime Data Area: JVM이라는 프로그램이 OS로부터 할당 받는 메모리 영역이다.</h3>
  </li>
</ol>

:ET