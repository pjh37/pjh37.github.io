I"6M<h1 id="http-vs-https">HTTP vs HTTPS</h1>

<h2 id="http의-문제점">HTTP의 문제점</h2>
<ul>
  <li>HTTP는 평문 통신으로 도청이 가능하다</li>
  <li>통신 상대를 확인하지 않기 때문에 위장이 가능하다</li>
  <li>완전성(정보의 정확성)을 증명할 수 없기 때문에 변조가 가능하다</li>
</ul>

<p><br /></p>

<h2 id="tcpip는-도청가능한-네트워크이다">TCP/IP는 도청가능한 네트워크이다</h2>
<h3 id="tcpip구조의-통신은-전부-통신-경로-상에서-패킷을-수집하는-것만으로-도청할-수-있기-때문에">TCP/IP구조의 통신은 전부 통신 경로 상에서 패킷을 수집하는 것만으로 도청할 수 있기 때문에</h3>
<h3 id="평문으로-통신을-할경우-암호화해서-통신해야-한다">평문으로 통신을 할경우 암호화해서 통신해야 한다</h3>

<h3 id="암호화-방법">암호화 방법</h3>
<ol>
  <li>통신자체를 암호화하는 것으로 SSL(Secure Socket Layer) or TLS(Transport Layer Security)를 이용한다</li>
  <li>HTTP메시지에 포함되는 콘텐츠만 암호화하는 방식으로 받은 측에서는 해독하여 출력하는 처리가 필요하다</li>
</ol>

<p><br /></p>
<h2 id="통신-상대를-확인하지-않기-때문에-위장이-가능하다">통신 상대를 확인하지 않기 때문에 위장이 가능하다</h2>
<h3 id="http에-의한-통신에서는-상대가-누구인지-확인하는-처리가-없기-때문에-누구든지-request를-보낼-수-있다">HTTP에 의한 통신에서는 상대가 누구인지 확인하는 처리가 없기 때문에 누구든지 request를 보낼 수 있다</h3>
<h3 id="웹서버에-엑세스-제한이-없는-경우-request가-오면-상대가-누구든-response를-반환한다-이러한-점은-여러가지-문제점을-일으킨다">웹서버에 엑세스 제한이 없는 경우 request가 오면 상대가 누구든 response를 반환한다. 이러한 점은 여러가지 문제점을 일으킨다</h3>

<p><br /></p>
<ol>
  <li>통신하고 있는 상대가 접근이 허가된 상대인지 확인불가</li>
  <li>어디에서 누가 request를 했는지 확인 불가</li>
  <li>의미없는 request도 수신하기 때문에 -&gt; Dos공격을 방지할 수 없다.</li>
  <li>request를 보낸 곳의 웹서버가 원래의도한 response를 보내야 하는 웹서버인지 확인할 수 없다.</li>
</ol>

<p><br /></p>
<h3 id="ssl를-통한-보완">SSL를 통한 보완</h3>
<ol>
  <li>ssl은 상대를 확인하는 수단으로 증명서를 제공한다</li>
  <li>증명서는 신뢰할 수 있는 제 3자기관에 의한 발행되는 것이기 때문에 서버,클라이언트가 실재하는 사실을 증명한다.</li>
  <li>클라이언트는 이 증명서로 본인확인,웹 사이트 인증에서도 사용할 수 있다.</li>
</ol>

<p><br /></p>
<h2 id="완전성정보의-정확성을-증명할-수-없기-때문에-변조가-가능하다">완전성(정보의 정확성)을 증명할 수 없기 때문에 변조가 가능하다</h2>
<h3 id="서버-또는-클라이언트에서-수신한-내용이-송신측에서-보낸-내용과-일치한다라는-것을-보장할-수-없다">서버 또는 클라이언트에서 수신한 내용이 송신측에서 보낸 내용과 일치한다라는 것을 보장할 수 없다.</h3>
<h3 id="왜냐하면-request-response가-발신된후에-상대가-수신하는-사이에-누군가에-의해-변조되더라도-이-사실을">왜냐하면 request, response가 발신된후에 상대가 수신하는 사이에 누군가에 의해 변조되더라도 이 사실을</h3>
<h3 id="알-수-없기-때문이다">알 수 없기 때문이다.</h3>

<p><br />
HTTPS
—–</p>
<h3 id="http가-통신하는-소켓부분을-ssl-or-tls라는-프로토콜로-대체하는-것으로-http는-원래-tcp와-직접-통신-했지만">http가 통신하는 소켓부분을 ssl or tls라는 프로토콜로 대체하는 것으로 http는 원래 tcp와 직접 통신 했지만</h3>
<h3 id="https에서-http는-ssl과-통신하고-ssl이-tcp와-통신하게-된다">https에서 http는 ssl과 통신하고 ssl이 tcp와 통신하게 된다.</h3>
<h3 id="https의-ssl에서는-공통키-암호화-방식과-공개키-암호화-방식을-혼합한-하이브리드-암호-시스템을-사용한다">https의 ssl에서는 공통키 암호화 방식과 공개키 암호화 방식을 혼합한 하이브리드 암호 시스템을 사용한다</h3>
<h3 id="공통키는-공개키-암호화-방식으로-교환한한-이후-통신은-공통키-암호를-사용하는-방식이다">공통키는 공개키 암호화 방식으로 교환한한 이후 통신은 공통키 암호를 사용하는 방식이다.</h3>

<p><br /></p>

<h2 id="ssl-인증서">SSL 인증서</h2>
<h3 id="ssl인증서는-클라이언트와-서버간의-통신을-제3자가-보증해주는-전자화된-문서다">SSL인증서는 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서다.</h3>
<h3 id="클라이언트가-서버에-접속하면-서버는-클라이언트에게-인증서-정보를-전달한다">클라이언트가 서버에 접속하면 서버는 클라이언트에게 인증서 정보를 전달한다.</h3>

<p><br /></p>

<h2 id="암호화-기법">암호화 기법</h2>

<p><br /></p>

<h2 id="대칭키">대칭키</h2>
<h3 id="암호화할때-사용하는-키와-복호화할때-사용하는-키가-같은것을-의미한다">암호화할때 사용하는 키와 복호화할때 사용하는 키가 같은것을 의미한다.</h3>
<h3 id="즉-동일한-키로-암호화와-복호화를-하는-것이다">즉, 동일한 키로 암호화와 복호화를 하는 것이다.</h3>

<p><br /></p>

<h2 id="공개키">공개키</h2>
<h3 id="대칭키-방식은-단점이-있다-암호를-주고-받는-사람들-사이에-대칭키를-전달하는-것이-어렵다">대칭키 방식은 단점이 있다. 암호를 주고 받는 사람들 사이에 대칭키를 전달하는 것이 어렵다</h3>
<h3 id="대칭키가-유출되면-키를-획득한-공격자는-암호의-내용을-복호화-할-수-있기-때문에-암호가-소용없어">대칭키가 유출되면 키를 획득한 공격자는 암호의 내용을 복호화 할 수 있기 때문에 암호가 소용없어</h3>
<h3 id="진다-이러한-배경에-나온것이-공개키-방식이다">진다. 이러한 배경에 나온것이 공개키 방식이다.</h3>

<p><br /></p>

<h3 id="공개키-방식은-두개의-키를-갖는다-a키로-암호화하면-b키로-복호화--b키로-암호화하면-a키로-복호화">공개키 방식은 두개의 키를 갖는다, A키로 암호화하면 B키로 복호화 , B키로 암호화하면 A키로 복호화</h3>
<h3 id="할-수-있다-이는-비밀키private-key와-공개키public-key로-나눌-수-있다">할 수 있다. 이는 비밀키(private key)와 공개키(public key)로 나눌 수 있다.</h3>
<h3 id="비밀키는-자신만-가지고-있고-공개키를-타인에게-제공한다-공개키를-제공받은-타인은-공개키를-이용해">비밀키는 자신만 가지고 있고 공개키를 타인에게 제공한다. 공개키를 제공받은 타인은 공개키를 이용해</h3>
<h3 id="정보를-암호화한다-암호화한-정보를-비밀키를-가지고-있는-사람에게전송한다-비밀키-소유자는">정보를 암호화한다. 암호화한 정보를 비밀키를 가지고 있는 사람에게전송한다. 비밀키 소유자는</h3>
<h3 id="이-키를-이용해서-암호화된-정보를-복호화한다-이-과정에서-공개키가-유출된다고-해도-비밀키를-모르면">이 키를 이용해서 암호화된 정보를 복호화한다. 이 과정에서 공개키가 유출된다고 해도 비밀키를 모르면</h3>
<h3 id="정보를-복호화할-수-없기-때문에-안전하다-공개키는-암호화할-수-있지만-복호화는-할-수-없기-때문이다">정보를 복호화할 수 없기 때문에 안전하다. 공개키는 암호화할 수 있지만 복호화는 할 수 없기 때문이다.</h3>

<p><br /></p>
<blockquote>
  <ul>
    <li>비공개키-&gt;비밀키 or개인키
      <h3 id="이러한-방식은-다른-방식으로-응용할-수-있다-비공개키의-소유자는-비공개키를-이용해서-정보를-암호화">이러한 방식은 다른 방식으로 응용할 수 있다. 비공개키의 소유자는 비공개키를 이용해서 정보를 암호화</h3>
      <h3 id="한-후에-공개키와-함께-암호화된-정보를-전송한다-정보와-공개키를-획득한-사람은-공개키를-이용해서">한 후에 공개키와 함께 암호화된 정보를 전송한다. 정보와 공개키를 획득한 사람은 공개키를 이용해서</h3>
      <h3 id="암호화된-정보를-복호화-한다-이-과정에서-공개키가-유출된다면-의도하지-않은-공격자에-의해서-데이터가">암호화된 정보를 복호화 한다. 이 과정에서 공개키가 유출된다면 의도하지 않은 공격자에 의해서 데이터가</h3>
      <h3 id="복호화-될-위험이-있다-이런-위험에도-불구하고-비공개키를-이용해서-암호화를-하는-이유는">복호화 될 위험이 있다. 이런 위험에도 불구하고 비공개키를 이용해서 암호화를 하는 이유는???</h3>
      <h3 id="그것은-이것이-데이터를-보호하는-것이-목적이-아니기-때문이다-암호화된-데이터를-공개키를-가지고-복호화">그것은 이것이 데이터를 보호하는 것이 목적이 아니기 때문이다. 암호화된 데이터를 공개키를 가지고 복호화</h3>
      <h3 id="할-수-있다는-것은-그-데이터가-공개키와-쌍을-이루는-비공개키에-의해서-암호화-되었다는-것을-의미한다">할 수 있다는 것은 그 데이터가 공개키와 쌍을 이루는 비공개키에 의해서 암호화 되었다는 것을 의미한다.</h3>
      <h3 id="즉-공개키가-데이터를-제공한-사람의-신원을-보장해주게-되는-것이다-이러한-것을-전자서명이라-한다">즉 공개키가 데이터를 제공한 사람의 신원을 보장해주게 되는 것이다. 이러한 것을 전자서명이라 한다.</h3>
    </li>
  </ul>
</blockquote>

<p><br /></p>

<h2 id="ssl인증서의-내용">SSL인증서의 내용</h2>
<ul>
  <li>
    <h3 id="서비스의-정보인증서를-발급한-ca-서비스의-도메인등">서비스의 정보(인증서를 발급한 CA, 서비스의 도메인등)</h3>
  </li>
  <li>
    <h3 id="서버-측-공개키공개키의-내용-공개키의-암호화-방법">서버 측 공개키(공개키의 내용 공개키의 암호화 방법)</h3>
  </li>
</ul>

<p><br /></p>

<h2 id="ssl인증서가-서비스를-보증하는-방법">SSL인증서가 서비스를 보증하는 방법</h2>
<ul>
  <li>
    <h3 id="웹-브라우저가-서버에-접속할-때-서버는-제일-먼저-인증서를-제공한다">웹 브라우저가 서버에 접속할 때 서버는 제일 먼저 인증서를 제공한다.</h3>
  </li>
  <li>
    <h3 id="브라우저는-이-인증서를-발급한ca가-브라우저-자신이-내장한-ca의-리스트에-있는지-확인한다">브라우저는 이 인증서를 발급한CA가 브라우저 자신이 내장한 CA의 리스트에 있는지 확인한다.</h3>
  </li>
  <li>
    <h3 id="확인-결과-서버를-통해서-다운받은-인증서가-내장된-ca리스트에-포함되어-있다면-해당-ca의">확인 결과 서버를 통해서 다운받은 인증서가 내장된 CA리스트에 포함되어 있다면 해당 CA의</h3>
    <h3 id="공개키를-이용해서-인증서를-복호화-한다-ca의-공개키를-이용해-복호화할-수-있다는-것은">공개키를 이용해서 인증서를 복호화 한다. CA의 공개키를 이용해 복호화할 수 있다는 것은</h3>
    <h3 id="이--인증서가-ca의-비공개키에-의해서-암호화-된-것을-의미한다">이  인증서가 CA의 비공개키에 의해서 암호화 된 것을 의미한다.</h3>
  </li>
  <li>
    <h3 id="해당-ca의-비공개키를-가지고-있는-ca는-해당-ca밖에-없기-때문에-서버가-제공한-인증서가">해당 CA의 비공개키를 가지고 있는 CA는 해당 CA밖에 없기 때문에 서버가 제공한 인증서가</h3>
    <h3 id="ca에-의해서-발급된-것이라는-것을-의미한다">CA에 의해서 발급된 것이라는 것을 의미한다.</h3>
  </li>
  <li>
    <h3 id="ca에-의해서-발급된-인증서-라는-것은-접속한-사이트가-ca에-의해서-검토-되었다는-것을-의미한다">CA에 의해서 발급된 인증서 라는 것은 접속한 사이트가 CA에 의해서 검토 되었다는 것을 의미한다.</h3>
  </li>
  <li>
    <h3 id="ca의-검토를-통과-했다는-것은-해당-서비스가-신뢰할-수-있다는-것을-의미한다">CA의 검토를 통과 했다는 것은 해당 서비스가 신뢰할 수 있다는 것을 의미한다.</h3>
  </li>
  <li>
    <h3 id="이것이-ca와-브라우저가-특정-서버를-인증하는-과정이다">이것이 CA와 브라우저가 특정 서버를 인증하는 과정이다.</h3>
  </li>
</ul>

<p><br /></p>

<h2 id="ssl의-동작방법">SSL의 동작방법</h2>
<h3 id="ssl은-공개키와-대칭키를-혼합해서-사용한다-클라이언트와-서버가-주고받는-실제-데이터는-대칭키">SSL은 공개키와 대칭키를 혼합해서 사용한다. 클라이언트와 서버가 주고받는 실제 데이터는 대칭키</h3>
<h3 id="방식으로-암호화하고-대칭키-방식으로-암호화된-실제-정보를-복호화할-때-사용하는-대칭키는-공개키">방식으로 암호화하고 대칭키 방식으로 암호화된 실제 정보를 복호화할 때 사용하는 대칭키는 공개키</h3>
<h3 id="방식으로-암호화해서-클라이언트와-서버가-주고-받는다">방식으로 암호화해서 클라이언트와 서버가 주고 받는다.</h3>

<p><br /></p>

<h3 id="컴퓨터와-컴퓨터가-네트워크를-통해-통신할때는-내부적으로-3단계가-있다">컴퓨터와 컴퓨터가 네트워크를 통해 통신할때는 내부적으로 3단계가 있다.</h3>
<blockquote>
  <p>handshake-&gt;전송-&gt;세션종료</p>
</blockquote>

<p><br /></p>

<h2 id="1-handshake">1. handshake</h2>

<p><br /></p>

<ol>
  <li>
    <h3 id="클라이언트가-서버에-접속한다-이-단계를-client-hello라고-한다-이-단계에서-주고받는-정보는-아래와-같다">클라이언트가 서버에 접속한다. 이 단계를 Client Hello라고 한다. 이 단계에서 주고받는 정보는 아래와 같다.</h3>
    <ul>
      <li>
        <h3 id="클라이언트-측에서-생성한-랜덤-데이터">클라이언트 측에서 생성한 랜덤 데이터</h3>
      </li>
      <li>
        <h3 id="클라이언트가-지원하는-암호화-방식들클라이언트와-서버가-지원하는-암호화-방식이-다를-수-있기-때문에">클라이언트가 지원하는 암호화 방식들:클라이언트와 서버가 지원하는 암호화 방식이 다를 수 있기 때문에</h3>
        <p>### 서로 어떤 암호화 방식을 사용할 것인지에 대한 협상</p>
      </li>
      <li>
        <h3 id="세션-아이디--이미-ssl-핸드쉐이킹을-했다면-기존의-세션을-재활용하는데-이때-사용할-연결에-대한-식별자를">세션 아이디 : 이미 SSL 핸드쉐이킹을 했다면 기존의 세션을 재활용하는데 이때 사용할 연결에 대한 식별자를</h3>
        <p>### 서버측으로 전송한다.</p>
      </li>
    </ul>
  </li>
</ol>

<p><br /></p>

<ol>
  <li>
    <h3 id="서버는-client-hello에-대한-응답으로-server-hello를-하게-된다-이-단계에서-주고-받는-정보는-아래와-같다">서버는 Client Hello에 대한 응답으로 Server Hello를 하게 된다. 이 단계에서 주고 받는 정보는 아래와 같다.</h3>
    <ul>
      <li>
        <h3 id="서버측에서-생성한-랜덤-데이터">서버측에서 생성한 랜덤 데이터</h3>
      </li>
      <li>
        <h3 id="서버가-선택한-클라이언트의-암호화-방식">서버가 선택한 클라이언트의 암호화 방식</h3>
      </li>
      <li>
        <h3 id="인증서">인증서</h3>
      </li>
    </ul>
  </li>
</ol>

<p><br /></p>

<ol>
  <li>
    <h3 id="클라이언트는-서버의-인증서가-ca에-의해서-발급된-것인지를-확인하기-위해서-클라이언트에-내장된-ca리스트를-확인한다">클라이언트는 서버의 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA리스트를 확인한다.</h3>
    <h3 id="ca리스트에-인증서가-없다면-경고-메시지-출력-인증서가-ca에-의해서-발급된-것인지를-확인하기-위해서-클라이언트에">CA리스트에 인증서가 없다면 경고 메시지 출력. 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에</h3>
    <h3 id="내장된-ca의-공개키를-이용해서-인증서를-복호화한다-복호화에-성공했다면-인증서는-ca의-개인키로-암호화된-문서임이">내장된 CA의 공개키를 이용해서 인증서를 복호화한다. 복호화에 성공했다면 인증서는 CA의 개인키로 암호화된 문서임이</h3>
    <h3 id="암시적으로-보장된다-인증서를-전송한-서버를-믿을-수-있게-된-것이다">암시적으로 보장된다. 인증서를 전송한 서버를 믿을 수 있게 된 것이다.</h3>
  </li>
</ol>

<p><br /></p>

<h3 id="클라이언트는-위의-12번과정을-통해서-받은-서버의-랜덤데이터-클라이언트가-생성한-랜덤-데이터를-조합해서">클라이언트는 위의 1,2번과정을 통해서 받은 서버의 랜덤데이터, 클라이언트가 생성한 랜덤 데이터를 조합해서</h3>
<h3 id="pre-master-secret라는-키를-생성한다-이-키는-세션-단계에서-데이터를-주고-받을-때-암호화하기-위해-사용될">pre master secret라는 키를 생성한다. 이 키는 세션 단계에서 데이터를 주고 받을 때 암호화하기 위해 사용될</h3>
<h3 id="것이다-이-때-사용할-암호화-기법은-대칭키이기-때문에-pre-master-secret값은-제-3자에게-노출되선-안된다">것이다. 이 때 사용할 암호화 기법은 대칭키이기 때문에 pre master secret값은 제 3자에게 노출되선 안된다.</h3>

<p><br /></p>

<h3 id="문제는-pre-master-secret값을-서버에-어떻게-전달할-것인가-이때-사용하는-방법이-바로-공개키-방시이다">문제는 pre master secret값을 서버에 어떻게 전달할 것인가? 이때 사용하는 방법이 바로 공개키 방시이다.</h3>
<h3 id="서버의-공개키로-pre-master-secret-값을-암호화해서-서버로-전송하면-서버는-자신의-비공개키로-안전하게-복호화">서버의 공개키로 pre master secret 값을 암호화해서 서버로 전송하면 서버는 자신의 비공개키로 안전하게 복호화</h3>
<h3 id="할-수-있다-그럼-서버의-공개키를-어떻게-구할-수-있는가-바로-서버로부터-받은-인증서-안에-들어있다">할 수 있다. 그럼 서버의 공개키를 어떻게 구할 수 있는가? 바로 서버로부터 받은 인증서 안에 들어있다.</h3>
<h3 id="이-서버의-공개키를-이용해서-pre-master-secret-값을-암호화한-후에-서버로-전송하면-안전하게-전송할-수-있다">이 서버의 공개키를 이용해서 pre master secret 값을 암호화한 후에 서버로 전송하면 안전하게 전송할 수 있다.</h3>

<p><br /></p>

:ET