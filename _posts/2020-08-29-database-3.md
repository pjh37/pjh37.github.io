---
layout: post
title:  " DB인덱스(index)"
date:   2020-08-29
desc: "index의 정의와 종류"
keywords: "database"
categories: [Database]
tags: [Database]
icon: icon-html
---

인덱스란?
====

### 인덱스는 지정한 컬럼들을 기준으로 메모리 영역에 일종의 목차를 생성하는 것이다.
### RDBMS에서 검색속도를 높이기위해 사용하는 기술이다.
### index는 색인으로 해당 테이블의 컬럼을 색인화(따로 파일로 저장)하여 검색시 해당 테이블의
### 레코드를 full scan하는게 아니라 색인화 되있는 index파일을 검색하여 검색속도를 빠르게한다.
### 인덱스는 insert,update,delete의 성능을 희생하고 select의 성능을 향상 시킨다.
> 여기서 주의점은 update,delete의 행위가 느린것이지, update,delete를 하기위해 해당 데이터를
> 조회하는것은 인덱스가 있으면 빠르게 조회가 된다.

<br/>

![인덱스이미지](https://user-images.githubusercontent.com/37110261/93494687-45122500-f948-11ea-870b-4e34a762d29b.png)

<br/>

## B-tree 인덱스 구조
+ ### 인덱스 탐색은 Root->Branch->leaf-> 디스크 저장소 순으로 진행된다.
    + ### Branch(페이지번호 2)는 dept_no가 d001이면서 emp_no가 10017~10024까지인 leaf의 부모로 있다.
    + ### 즉, dept_no=d001 and emp_no=10018로 조회하면 페이지 번호 4인 Leaf를 찾아 데이터 파일의 주소를 불러와 반환하는 과정을 하게 됩니다.
+ ### 디스크에서 읽는 것은 메모리에서 읽는것보다 성능이 훨씬 떨어진다.
    + ### 결국 인덱스 성능을 향상시킨다는 것은 디스크 저장소에 얼마나 덜 접근하게 만드느냐, 인덱스 Root에서 Leaf까지 오고가는 횟수를 얼마나 줄이느냐에 달려있다.
<br/>

## Clustered Index vs Non-Clustered Index
### 클러스터드 인덱스
+ ### 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식이다.
+ ### 실제 데이터가 순서대로 저장되어 있어 인덱스를 검색하지 않아도 데이터를 빠르게 조회 가능
+ ### 데이터 삽입,삭제 발생시 순서 유지를 위해 데이터 재정렬을 하기때문에 삽입,삭제가 느리다.
+ ### 한 개의 테이블에 하나의 인덱스만 생성할 수 있다.

<br/>

### 넌클러스터드 인덱스
+ ### 인덱스의 키값만 정렬 되있을뿐 실제 데이터는 정렬되지 않는 방식이다.
+ ### 데이터를 검색하기 위해서 먼저 인덱스를 검색하여 실제 데이터의 위치를 확인해야 하므로
### 검색속도가 떨어진다.
+ ### 한 개의 테이블에 여러개 생성 가능
### 클러스터드 인덱스에 비해 검색 속도가 떨어진다.