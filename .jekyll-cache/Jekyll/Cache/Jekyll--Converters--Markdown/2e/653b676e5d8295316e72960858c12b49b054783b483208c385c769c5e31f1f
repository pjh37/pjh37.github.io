I"$<h1 id="java-jvm">Java jvm</h1>

<h3 id="jvm은-java와-os사이에서-중개자-역할을-하며-java가-os에-구애받지-않고-재사용을-가능하게">jvm은 java와 os사이에서 중개자 역할을 하며 java가 os에 구애받지 않고 재사용을 가능하게</h3>
<h3 id="해준다-그리고-메모리관리-gc를-수행한다">해준다. 그리고 메모리관리, GC를 수행한다.</h3>
<h3 id="그리고-jvm은-스택기반이다">그리고 jvm은 스택기반이다.</h3>

<p><br /></p>

<h2 id="자바프로그램-실행과정">자바프로그램 실행과정</h2>
<blockquote>
  <ol>
    <li>프로그램이 실행되면 JVM은 OS로부터 이 프로그램이 필요로 하는 메모리를 할당 받는다.
JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.</li>
    <li>자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어 자바 바이트코드(.class)로 변환</li>
    <li>Class Loader를 통해 class파일들을 JVM으로 로딩한다.</li>
    <li>로딩된 class파일들은 Execution engine을 통해 해석된다.(로딩된 바이트 코드-&gt;바이너리 코드로 변경)</li>
    <li>해석된 바이트 코드는 Runtime Data Area에 배치되어 실질적인 수행이 이루어지게 된다.
이러한 실행 과정 속에서 JVM은 필요에 따라 Thread Synchronization과 GC같은 작업을 한다.</li>
  </ol>
</blockquote>

<p><br /></p>

<h2 id="jvm-구성">jvm 구성</h2>

<ol>
  <li>
    <h3 id="java-complier-java-소스-파일을-jvm이-해석할-수-있는-java-byte-codeclass파일">Java Complier: java 소스 파일을 jvm이 해석할 수 있는 Java Byte Code(.class파일)</h3>
    <p>로 변경한다. 일반적인 윈도우 프로그램에서는 컴파일이후 어셈블리 파일이 생성된다.</p>
  </li>
  <li>
    <h3 id="class-loader-jvm으로-class파일들을-load한다-loading된-클래스들은">Class Loader: JVM으로 .class파일들을 Load한다. Loading된 클래스들은</h3>
    <p>Runtime data area에 배치된다. 일반적인 윈도우 프로그램의 경우 Load는 os가 주도</p>
  </li>
  <li>
    <h3 id="execution-engine-loading된-클래스의-bytecode를-해석interpret한다-이-과정에서">Execution Engine: Loading된 클래스의 Bytecode를 해석(Interpret)한다. 이 과정에서</h3>
    <p>Bytecode가 Binary Code로 변경된다.</p>
  </li>
  <li>
    <h3 id="runtime-data-area-jvm이라는-프로그램이-os로부터-할당-받는-메모리-영역이다">Runtime Data Area: JVM이라는 프로그램이 OS로부터 할당 받는 메모리 영역이다.</h3>
  </li>
</ol>

<p><br /></p>

<h2 id="구성요소-세부설명">구성요소 세부설명</h2>
<h3 id="클래스-로더class-loader">클래스 로더(Class Loader)</h3>
<h3 id="3가지-역할-담당">3가지 역할 담당</h3>
<ul>
  <li>
    <h3 id="loading">Loading</h3>
  </li>
  <li>
    <h3 id="linking">Linking</h3>
  </li>
  <li>
    <h3 id="inititalzation">Inititalzation</h3>
  </li>
</ul>

<p><br /></p>

<h3 id="1-loading">1. Loading</h3>

<h3 id="클래스-로더는-class파일을-읽어-바이트-코드를-메소드-영역에-저장한다">클래스 로더는 .class파일을 읽어 바이트 코드를 메소드 영역에 저장한다.</h3>
<h3 id="각-class파일은-jvm에-의해-메소드-영역에-다음의-정보를-저장한다">각 .class파일은 JVM에 의해 메소드 영역에 다음의 정보를 저장한다.</h3>
<ul>
  <li>
    <h3 id="로드된-클래스를-비롯한-그의-부모-클래스의-정보">로드된 클래스를 비롯한 그의 부모 클래스의 정보</h3>
  </li>
  <li>
    <h3 id="class파일이-classinterfaceenum과-관련여부">class파일이 Class,Interface,Enum과 관련여부</h3>
  </li>
  <li>
    <h3 id="변수나-메소드의-정보등">변수나 메소드의 정보등</h3>
    <h3 id="class파일이-로딩된-후에는-jvm은-힙-메모리-영역에-이-파일이-나타내는-클래스-유형의-객체를">.class파일이 로딩된 후에는 JVM은 힙 메모리 영역에 이 파일이 나타내는 클래스 유형의 객체를</h3>
    <h3 id="생성한다-이-클래스-객체를-이용하면-클래스의-이름-및-부모-클래스-이름메소드변수-정보를">생성한다. 이 클래스 객체를 이용하면 클래스의 이름 및 부모 클래스 이름,메소드,변수 정보를</h3>
    <h3 id="보여줄-수-있다">보여줄 수 있다.</h3>
  </li>
</ul>

<p><br /></p>

<h3 id="2-linking">2. Linking</h3>

<h3 id="verification증명-preparation준비-resolution-3가지를-수행한다">verification(증명), preparation(준비), resolution 3가지를 수행한다.</h3>
<ul>
  <li>
    <h3 id="verification--class파일의-정확성을-보장한다-파일이-적절히-포맷되었는지유효한-컴파일러에-의해">Verification : .class파일의 정확성을 보장한다. 파일이 적절히 포맷되었는지,유효한 컴파일러에 의해</h3>
    <p>생성되었는지 확인, 검증 실패시 런타임 에러</p>
  </li>
  <li>
    <h3 id="preparation--jvm은-메모리를-기본-값으로-초기화-한-후-클래스-변수들을-위한-메모리를-할당한다">Preparation : JVM은 메모리를 기본 값으로 초기화 한 후, 클래스 변수들을 위한 메모리를 할당한다.</h3>
  </li>
  <li>
    <h3 id="resolution--symbolic-references-를-direct-references-로-바꾸는-프로세스">Resolution : symbolic references 를 direct references 로 바꾸는 프로세스.</h3>
  </li>
</ul>

<p><br /></p>

<h3 id="3-inititalzation">3. Inititalzation</h3>

<h3 id="모든-정적-변수들이-정의된-값으로-초기화-된다">모든 정적 변수들이 정의된 값으로 초기화 된다.</h3>

<p><br /></p>

<h2 id="클래스로더는-3가지-종류가-있다">클래스로더는 3가지 종류가 있다.</h2>
<ul>
  <li>
    <h3 id="bootstrap-class-loader--모든-jvm구현에는-신뢰된-클래스들을-로딩하기위해-부트스트랩-클래스">Bootstrap class Loader : 모든 JVM구현에는 신뢰된 클래스들을 로딩하기위해 부트스트랩 클래스</h3>
    <h3 id="로더가-필요하다-이-로더는-java_homejrelib-디렉토리에-존재하는-핵심-java-api들을-로드한다">로더가 필요하다. 이 로더는 JAVA_HOME/jre/lib 디렉토리에 존재하는 핵심 java API들을 로드한다.</h3>
    <h3 id="또한-java가-아닌-cc같은-네이티브언어를-통해-구현되있다">또한 Java가 아닌 c,c++같은 네이티브언어를 통해 구현되있다.</h3>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <h3 id="extension-class-loader--부트스트랩-클래스-로더의-자식이다-java_homejrelibext또는">Extension class loader : 부트스트랩 클래스 로더의 자식이다. JAVA_HOME/jre/lib/ext또는</h3>
    <h3 id="javaextdirs시스템-속성으로-명시된-다른-특정-디렉토리인-확장-디렉토리-안에-존재하는-클래스들을-로드">java.ext.dirs시스템 속성으로 명시된 다른 특정 디렉토리인 확장 디렉토리 안에 존재하는 클래스들을 로드</h3>
    <h3 id="한다-java로-구현되어있다">한다. java로 구현되어있다.</h3>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <h3 id="systemapplication-class-loader--확장-클래스-로더의-자식이다-application-class경로부터">System/Application class loader : 확장 클래스 로더의 자식이다. application class경로부터</h3>
    <h3 id="클래스들을-로드한다-내부적으로-javaclasspath에-매핑된-환경변수를-사용한다-사용자가-만든-class">클래스들을 로드한다. 내부적으로 java.class.path에 매핑된 환경변수를 사용한다. 사용자가 만든 .class</h3>
    <h3 id="확장자-파일을-이-로더가-로딩하는-것이다">확장자 파일을 이 로더가 로딩하는 것이다.</h3>
  </li>
</ul>

<p><br /></p>

<p><img src="https://user-images.githubusercontent.com/37110261/90983276-cecc0e00-e5a7-11ea-8f7e-f021d6a29284.png" alt="classloader" /></p>

<p><br /></p>

<h3 id="jvm은-클래스들을-로드하기-위해-위임-계층delegation-hierarchy원리를-따른다">JVM은 클래스들을 로드하기 위해 위임-계층(Delegation-Hierarchy)원리를 따른다.</h3>
<h3 id="시스템-클래스-로더는-로드-요청을-확장-클래스로더로-요청하고-확장-클래스로더는-부트-스트랩">시스템 클래스 로더는 로드 요청을 확장 클래스로더로 요청하고 확장 클래스로더는 부트 스트랩</h3>
<h3 id="클래스-로더에게-위임하게-된다">클래스 로더에게 위임하게 된다.</h3>
<h3 id="부트스트랩-로더에서-클래스를-찾지-못하면-확장-로더에서-찾고-못찾으면-시스템-로더에서-찾게-된다">부트스트랩 로더에서 클래스를 찾지 못하면, 확장 로더에서 찾고 못찾으면 시스템 로더에서 찾게 된다.</h3>
<h3 id="마지막으로-시스템로더에서도-클래스-로드를-실패한다면-classnotfoundexception런타임-에러를">마지막으로 시스템로더에서도 클래스 로드를 실패한다면 ClassNotFoundException런타임 에러를</h3>
<h3 id="볼-수-있다">볼 수 있다.</h3>
:ET