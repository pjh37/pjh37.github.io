I"(<h1 id="java-garbage-collection">Java Garbage Collection</h1>

<p><br /></p>
<h2 id="가비지-컬렉션-과정">가비지 컬렉션 과정</h2>
<h3 id="gc를-알아보기전-stop-the-world라는-용어를-알아야한다">GC를 알아보기전 ‘stop the world’라는 용어를 알아야한다</h3>
<blockquote>
  <p>‘stop the world’란 GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것이다</p>
</blockquote>

<h3 id="stop-the-world가-발생하면-gc를-실행하는-쓰레드를-제외한-나머지-쓰레드는-모두-작업을-멈춘다">‘stop the world’가 발생하면 GC를 실행하는 쓰레드를 제외한 나머지 쓰레드는 모두 작업을 멈춘다</h3>
<h3 id="gc작업을-완료한-이후-중단했던-작업을-다시-시작한다-어떤-gc알고리즘을-사용하더라도">GC작업을 완료한 이후 중단했던 작업을 다시 시작한다. 어떤 GC알고리즘을 사용하더라도</h3>
<h3 id="stop-the-world는-발생한다-대개의-경우-gc튜닝이란-이-stop-the-world-시간을-줄이는-것이다">‘stop the world’는 발생한다. 대개의 경우 GC튜닝이란 이 ‘stop the world’ 시간을 줄이는 것이다.</h3>

<p><br /></p>

<h3 id="java에서는-개발자가-메모리를-명시적으로-해제하지-않기-때문에-gc가-필요없는-객체를-찾아">Java에서는 개발자가 메모리를 명시적으로 해제하지 않기 때문에 GC가 필요없는 객체를 찾아</h3>
<h3 id="지우는-작업을-한다-gc는-다음의-두가지-전제하에-만들어졌다">지우는 작업을 한다. GC는 다음의 두가지 전제하에 만들어졌다.</h3>

<p><br /></p>

<ul>
  <li>
    <h3 id="대부분의-객체는-금방-접근-불가능이-된다">대부분의 객체는 금방 접근 불가능이 된다.</h3>
  </li>
  <li>
    <h3 id="오래된-객체에서-젊은-객체로의-참조는-아주-적게-존재한다">오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다.</h3>
  </li>
</ul>

<p><br /></p>

<h3 id="이러한-전제-조건에-따라-크게-2개의-물리적-공간을-나누었는데-young-영역과-old영역">이러한 전제 조건에 따라 크게 2개의 물리적 공간을 나누었는데 ‘young’ 영역과 ‘old’영역</h3>
<h3 id="이다">이다.</h3>

<p><br /></p>

<ul>
  <li>
    <h3 id="young영역--새롭게-생성한-객체의-대부분이-여기에-위치한다-대부분의-객체가-금방-접근">Young영역 : 새롭게 생성한 객체의 대부분이 여기에 위치한다. 대부분의 객체가 금방 접근</h3>
    <h3 id="불가능-상태가-되기-때문에-많은-객체가-young영역에-생성되었다가-사라진다-이-영역에서">불가능 상태가 되기 때문에 많은 객체가 Young영역에 생성되었다가 사라진다. 이 영역에서</h3>
    <h3 id="객체가-사라질때-minor-gc가-발생한다고-말한다">객체가 사라질때 Minor GC가 발생한다고 말한다.</h3>
  </li>
  <li>
    <h3 id="old영역--접근-불가능-상태로-되지-않아-young영역에서-살아남은-객체가-여기로-복사된다">Old영역 : 접근 불가능 상태로 되지 않아 Young영역에서 살아남은 객체가 여기로 복사된다.</h3>
    <h3 id="대부분-young영역보다-크게-할당하며-크기가-큰-만큼-young영역보다-gc는-적게-발생한다">대부분 Young영역보다 크게 할당하며, 크기가 큰 만큼 Young영역보다 GC는 적게 발생한다.</h3>
    <h3 id="이-영역-에서-객체가-사라질때-full-gc가-발생한다고-말한다">이 영역 에서 객체가 사라질때 Full GC가 발생한다고 말한다.</h3>
  </li>
</ul>

<p><br /></p>

<p><img src="https://user-images.githubusercontent.com/37110261/86885427-3fba8200-c130-11ea-8d0f-54befeb4b7e2.png" alt="gc그림" /></p>

<p><br /></p>

<h3 id="위-그림의-permanent-genernation-영역-은-method-area라고도-한다-객체나-문자열정보를">위 그림의 Permanent Genernation 영역 은 Method area라고도 한다. 객체나 문자열정보를</h3>
<h3 id="저장하는-곳이며-old영역에서-살아남은-객체가-영원히-남아-있는-곳은-아니다-이-영역에서">저장하는 곳이며 Old영역에서 살아남은 객체가 영원히 남아 있는 곳은 아니다. 이 영역에서</h3>
<h3 id="gc가-발생할-수도-있는데-여기서-발생해도-full-gc의-횟수에-포함된다">GC가 발생할 수도 있는데 여기서 발생해도 Full GC의 횟수에 포함된다.</h3>

<p><br /></p>

<h2 id="young-영역의-구성">Young 영역의 구성</h2>
<h3 id="young-영역은-3개의-영역으로-나뉜다">Young 영역은 3개의 영역으로 나뉜다.</h3>
<ul>
  <li>
    <h3 id="eden-영역">Eden 영역</h3>
  </li>
  <li>
    <h3 id="survivor-영역-2개">Survivor 영역 (2개)</h3>
  </li>
</ul>

<p><br /></p>

<h3 id="각-영역의-처리-절차-순서">각 영역의 처리 절차 순서</h3>
<ul>
  <li>
    <h3 id="새로-생성한-대부분의-객체는-eden영역에-위치한다">새로 생성한 대부분의 객체는 Eden영역에 위치한다.</h3>
  </li>
  <li>
    <h3 id="eden-영역에서-gc가-한-번-발생한-후-살아남은-객체는-survivor-영역-중-하나로-이동된다">Eden 영역에서 GC가 한 번 발생한 후 살아남은 객체는 Survivor 영역 중 하나로 이동된다.</h3>
  </li>
  <li>
    <h3 id="eden-영역에서-gc가-발생하면-이미-살아남은-객체가-존재하는-survivor-영역으로-객체가-계속-쌓인다">Eden 영역에서 GC가 발생하면 이미 살아남은 객체가 존재하는 Survivor 영역으로 객체가 계속 쌓인다.</h3>
  </li>
  <li>
    <h3 id="하나의-survivor-영역이-가득-차게-되면-그-중에서-살아남은-객체를-다른-survivor-영역">하나의 Survivor 영역이 가득 차게 되면 그 중에서 살아남은 객체를 다른 Survivor 영역</h3>
    <h3 id="으로-이동한다-그리고-가득찬-survivor-영역은-아무-데이터도-없는-상태로-된다">으로 이동한다. 그리고 가득찬 Survivor 영역은 아무 데이터도 없는 상태로 된다.</h3>
  </li>
  <li>
    <h3 id="이-과정을-반복하다가-계속해서-살아남아-있는-객체는-old영역으로-이동하게-된다">이 과정을 반복하다가 계속해서 살아남아 있는 객체는 Old영역으로 이동하게 된다.</h3>
  </li>
</ul>

<p><br /></p>

<h3 id="이-절차에서-survivor-영역-중-하나는-반드시-비어-있는-상태로-남아-있어야-한다">이 절차에서 Survivor 영역 중 하나는 반드시 비어 있는 상태로 남아 있어야 한다.</h3>
<h3 id="만약-두-survivor-영역에-모두-데이터가-존재하거나-두-영역-모두-사용량이-0이라면-시스템">만약 두 Survivor 영역에 모두 데이터가 존재하거나, 두 영역 모두 사용량이 0이라면 시스템</h3>
<h3 id="이-정상적인-상황이-아닌-것이다">이 정상적인 상황이 아닌 것이다.</h3>

<p><br /></p>

<h3 id="이-절차를-그림으로-보면-다음과-같다">이 절차를 그림으로 보면 다음과 같다.</h3>
<p><img src="https://user-images.githubusercontent.com/37110261/86889179-4d730600-c136-11ea-9507-bc7a074e2f12.png" alt="gc_young" /></p>

<p><br /></p>
<h2 id="핵심-point--eden-영역에서-최초로-객체가-만들어지고-survivor영역을-통해서">핵심 Point : Eden 영역에서 최초로 객체가 만들어지고, Survivor영역을 통해서</h2>
<h2 id="old영역으로-오래-살아남은-객체가-이동한다는-사실은-꼭-기억하자">Old영역으로 오래 살아남은 객체가 이동한다는 사실은 꼭 기억하자</h2>

<p><br /></p>

<h2 id="old-영역에-대한-gc">Old 영역에 대한 GC</h2>
<h3 id="old-영역은-기본적으로-데이터가-가득-차면-gc를-실행한다-gc방식은-jdk7을-기준으로">Old 영역은 기본적으로 데이터가 가득 차면 GC를 실행한다. GC방식은 JDK7을 기준으로</h3>
<h3 id="5가지-방식이-있다">5가지 방식이 있다.</h3>

<p><br /></p>
<ul>
  <li>
    <h3 id="serial-gc">Serial GC</h3>
  </li>
  <li>
    <h3 id="parallel-gc">Parallel GC</h3>
  </li>
  <li>
    <h3 id="parallel-old-gcparallel-compacting-gc">Parallel Old GC(Parallel Compacting GC)</h3>
  </li>
  <li>
    <h3 id="concurrent-mark--sweep-gc이하-cms">Concurrent Mark &amp; Sweep GC(이하 CMS)</h3>
  </li>
  <li>
    <h3 id="g1garbage-first-gc">G1(Garbage First) GC</h3>
  </li>
</ul>

<p><br /></p>

<h3 id="이-중에서-serial-gc는-운영서버에서-절대-사용하면-안된다-cpu코어가-하나만-있을-때">이 중에서 Serial GC는 운영서버에서 절대 사용하면 안된다. CPU코어가 하나만 있을 때</h3>
<h3 id="사용하기-위해서-만든-방식이기-때문에-사용시-애플리케이션-성능이-많이-떨어진다">사용하기 위해서 만든 방식이기 때문에 사용시 애플리케이션 성능이 많이 떨어진다.</h3>

<p><br /></p>

<h2 id="serial-gc-1">Serial GC</h2>
<h3 id="young에서는-앞서-말한-방식을-사용-old영역에서는-mark-sweep-compact-콜렉션-알고리즘을--따릅니다-이-알고리즘에-대해서-간단하게-말하면-안-쓰는-거-표시해서-삭제하고-한-곳으로--모으는-알고리즘입니다">young에서는 앞서 말한 방식을 사용, old영역에서는 Mark-sweep-compact 콜렉션 알고리즘을 ### 따릅니다. 이 알고리즘에 대해서 간단하게 말하면, 안 쓰는 거 표시해서 삭제하고 한 곳으로 ### 모으는 알고리즘입니다.</h3>

<blockquote>
  <p>*Mark-sweep-compact</p>
  <ul>
    <li>
      <h3 id="old-영역으로-이동된-객체들-중-살아-있는-개체를-식별합니다-mark">Old 영역으로 이동된 객체들 중 살아 있는 개체를 식별합니다. (Mark)</h3>
    </li>
    <li>
      <h3 id="old-영역의-객체들을-훑는-작업을-수행하여-쓰레기-객체를-식별합니다-sweep">Old 영역의 객체들을 훑는 작업을 수행하여 쓰레기 객체를 식별합니다. (Sweep)</h3>
    </li>
    <li>
      <h3 id="필요-없는-객체들을-지우고-살아-있는-객체들을-한-곳으로-모은다-compact">필요 없는 객체들을 지우고 살아 있는 객체들을 한 곳으로 모은다 (Compact)</h3>
    </li>
  </ul>
</blockquote>

:ET