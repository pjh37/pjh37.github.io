---
layout: post
title:  " Kafka 개요"
date:   2022-03-26
desc: "카프카 개요 소개"
keywords: "Kafka"
categories: [Kafka]
tags: [kafka]
icon: icon-html
---

## 카프카 사용이유

+ 중앙화된 전송영역이 없어 end to end 연결이 복잡해진다.
+ 데이터 파이프라인 관리가 어려워짐
+ 연결 시스템마다 다른 방식으로 구현될 수 있다.

![image4](https://user-images.githubusercontent.com/37110261/160599457-90ef57a9-377f-477b-9253-99ebd1368f01.PNG)

## 메시지 발행과 구독

+ 메시지 발행 시스템에서는 데이터를 발행자 가 직접 구독자에게 보내지 않는다.

![image1](https://user-images.githubusercontent.com/37110261/160224437-39320408-f199-4d27-a7d8-ac60055c9bb5.PNG)

<br/>

+ 메시지는 발행자가 메시지를 구분해서 발행/구독 시스템에 전송하면 구독자가 특정 부류의 메시지를 구독하게 해준다. 이때 메시지를 저장하고 중계하는 역할을 브로커라고 한다.

![image2](https://user-images.githubusercontent.com/37110261/160224513-2bfc3e3a-3b54-4f24-bfa7-62aa02e77015.PNG)


<br/>

## Kafka 정의

+ Distributed commit log
+ Dittributed streaming platform
+ -> 데이터를 지속해서 저장하고 읽을 수 있으며 확장에 따른 성능저하를 방지하기위해 데이터가 분산 처리될 수 있다.

## 메시지와 배치
+ 데이터의 기본 단위로서 메시지 사용
+ 메시지를 바이트 배열의 데이터로 간주하므로 특정 형식이나 의미를 갖지 않는다.
+ 카프카의 메시지 데이터는 topic로 분류된 partition에 수록되는데 이때 데이터를 수록할 파티션을 결정하기위해 일관된 해시 값으로 키를 생성한다.
+ 카프카는 메시지가 생길때마다 보내는게 아닌 효율성을 위해 모아서 전송하는 형태의 배치로 파티션에 전송할 수 있다.
    + 이 경우 latency와 throughput(처리량) 과 트레이드 오프 가 생길 수 있다.
    + 배치의 크기 증가 -> 단위 시간당 처리되는 메시지 양 증가
    + 배치의 크기 증가 -> 메시지의 전송 시간 증가
    + ![image3](https://user-images.githubusercontent.com/37110261/160224851-5ddfc429-96cf-4fbf-8a44-d77443f2137a.PNG)


<br/>

## 스키마
+ 카프카는 메시지를 바이트 배열로 처리하지만 내용 이해를 위해 메시지의 구조를 스키마로 표현할 수 있다.
+ ex) Json, XML
+ Avro 사용

<br/>

## 토픽과 파티션

+ 카프카의 메시지는 토픽(topic)으로 분류하며 토픽은 DB의 테이블, 파일 시스템의 폴더와 유사
+ 토픽은 여러개의 파티션으로 구성된다.
+ 메시지는 파티션에 추가되는 형태로만 수록
+ 맨 앞부터 끝까지 순서대로 읽힌다.
+ <span style="color:red;">메시지의 처리 순서는 토픽이 아닌 파티션별로 유지 관리된다.</span>
+ 각 파티션은 서로 다른 서버에 분산(서로 다른 브로커에) 될 수 있다.


<br/>

![0_dEeuSOb7Z8K7---q](https://user-images.githubusercontent.com/37110261/160225181-ebb987eb-7a04-4e50-b0e2-7395b4cb65b5.png)

<br/>

## 프로듀서와 컨슈머

### Producer
+ 새로운 메시지를 발행
+ 메시지는 특정 토픽으로 생성되며 어떤 파티션에 수록되는지 보통 관여하지 않음
+ 프로듀서가 특정 파티션에 메시지를 직접 쓰는 경우 메시지키와 파티셔너를 이용해 해시값을 생성하고 특정 파티션에 대응시켜 항상 같은 파티션에 수록되게 해준다.

<br/>

### Consumer
+ 메시지를 읽는 주체
+ 하나 이상의 토픽을 구독하여 <span style="color:red;">메시지가 생성된 순서</span> 대로 읽는다.
+ 메시지의 오프셋을 유지하여 메시지의 읽는 위치를 알 수 있다.
+ <span style="color:red;">오프셋은 지속적으로 증가하는 정수값</span>이며 메시지가 생성될때 카프카가 추가해준다.
+ 파티션에 수록된 각 메시지는 고유한 오프셋을 갖는다.
+ <span style="color:red;">주키퍼나 카프카에서는 각 파티션에서 마지막에 읽은 메시지의 오프셋을 저장</span>하고 있으므로 컨슈머가 메시지 읽기를 중단했다 다시 시작해도 언제든 다음부터 읽을 수 있다.

<br/>

![0_Wb1KAsJRad_QEX2Z](https://user-images.githubusercontent.com/37110261/160225543-00010031-5c1c-47b2-b4cd-e72f0b201e4b.png)

+ 컨슈머는 컨슈머그룹의 멤버로 동작
+ 한 토픽을 소비하기위해 같은 그룹의 여러 컨슈머가 함께 동작한다.
+ <span style="color:red;">한 토픽의 각 파티션은 하나의 컨슈머만 소비할 수 있다.</span>
+ 한 컨슈머가 자신의 파티션 메시지를 읽는데 실패해도 같은 그룹의 다른 컨슈머가 파티션 소유권을 재조정 받고 실패한 컨슈머의 파티션 메시지를 대신 읽을 수 있다.

<br/>


## 브로커와 클러스터
+ 하나의 카프카 서버를 브로커라고 한다.
+ 프로듀서로부터 메시지를 수신하고 오프셋을 지정한 후 해당 메시지를 디스크에 저장한다.
+ 카프카의 브로커는 클러스터의 일부로 동작하도록 설계됨
+ 여러개의 브로커가 하나의 클러스터에 포함 가능
+ 여러개의 브로커중 1개는 클러스터 컨트롤러의 기능 수행
    + 클로스터 컨트롤러는 각 브로커에게 담당 파티션 할당,브로커들의 정상 동작 유무 감시및 모니터링

+ 각 파티션은 클러스터의 한 브로커가 소유, 그 브로커를 파티션 리더라고 한다.
+ 같은 파티션이 여러 브로커에 지정 될 수도 있으며 이때 해당 파티션이 복제된다 이때 메시지는 중복저장 되지만 관련 브로커에 장애 발생시 다른 브로커가 소유권을 인계 받아 그 파티션을 처리할 수 있다.
    + ex) db의 master slave의 동작 원리와 유사하다.
+ 각 파티션을 사용하는 모든 컨슈머와 프로듀서는 파티션 리더에 연결해야 한다.

![다운로드](https://user-images.githubusercontent.com/37110261/160225978-126c17cc-7d88-4441-814e-758a50b7aea9.png)


<br/>

## 다중 클러스터

+ 데이터 타입 따라 구분및 처리
+ 요구사항에 따라 분리 처리
+ 다중 데이터 센터 처리

### 다중 클러스터를 지원하기 위해 미러 메이커를 사용한다.
### 미러 메이커또한 컨슈머와 프로듀서이며 미러메이커 끼리는 큐로 상호 연결된다.


<br/>

## 카프카를 사용하는 이유

+ 다중 프로듀서,컨슈머

![캡처](https://user-images.githubusercontent.com/37110261/160226331-74abcd26-48ae-486c-bb8c-c29eafdbf14f.PNG)

+ 다중 프로듀서,컨슈머가 상호 간섭없이 어떤 메시지 스트림도 읽을 수 있다.

+ 디스크 기반 보존
    + 메시지를 보존할 수 있어 컨슈머를 항상 실시간 실행시키지 않아도 된다.
    + 처리가 느리거나 접속이 폭주해서 메시지 읽는데 실패해도 데이터가 유실될 위험이 적다.


+ 확장성
    + 브로커 1대부터 시작하여 규모에 따라 브로커를 수백대로 증가 시키고 대규모 클러스터로 묶어 사용할 수 있다.
    + 동시에 여러 브로커에서 장애가 생겨도 복제 팩터를 더 큰 값으로 했다면 대응할 수 있다.


<br/>

## 이용 사례
+ 활동 추적
+ 메시지 전송(메일, 푸시알림 등)
+ 메트릭 로깅
+ 커밋로그
+ 스트림 프로세싱