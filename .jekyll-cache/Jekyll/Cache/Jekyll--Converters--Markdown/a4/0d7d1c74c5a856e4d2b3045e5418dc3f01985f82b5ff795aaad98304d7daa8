I"<h1 id="tcp-3-way-handshake">TCP 3-way-handshake</h1>

<p><br /></p>

<h2 id="3-way-handshake란">3-way-handshake란</h2>

<h3 id="tcp-3-way-handshake는-tcpip프로토콜을-이용해서-통신을-하는-응용프로그램이-데이터를-전송하기-전에">tcp 3-way-handshake는 TCP/IP프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에</h3>
<h3 id="먼저-정확한-전송을-보장하기-위해-상대방-컴퓨터와-사전에-세션을-수립하는-과정을-의미한다">먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.</h3>

<p><br /></p>
<h2 id="순서">순서</h2>
<h3 id="1-client---server-tcp-syn">1. Client -&gt; Server tcp SYN</h3>
<h3 id="2-server---client-tcp-syn-ack">2. Server -&gt; Client tcp SYN ACK</h3>
<h3 id="3-client---server-tcp-ack">3. Client -&gt; Server tcp ACK</h3>

<blockquote>
  <p>SYN: synchronize sequence numbers <br />
ACK: acknowledgment</p>
</blockquote>

<p><br /></p>

<h2 id="3-way-handshake-과정">3-way-handshake 과정</h2>
<hr />

<p><img src="https://user-images.githubusercontent.com/37110261/82871498-a44cc380-9f6c-11ea-9092-528271d37fee.png" alt="3way" /></p>

<p><br /></p>

<h3 id="1-클라이언트는-서버에-접속을-요청하는-syn패킷을-보낸다-이때-클라이언트는-synack-응답을-기다리는">1. 클라이언트는 서버에 접속을 요청하는 SYN패킷을 보낸다. 이때 클라이언트는 SYN/ACK 응답을 기다리는</h3>
<h3 id="synsent상태가-된다">SYN/SENT상태가 된다.</h3>

<p><br /></p>
<h3 id="2-서버는-syn요청을-받고-클라이언트의-요청을-수락한다는-ack와-syn-패킷을-발송하고-클라이언트가-다시">2. 서버는 SYN요청을 받고 클라이언트의 요청을 수락한다는 ACK와 SYN 패킷을 발송하고 클라이언트가 다시</h3>
<h3 id="ack패킷으로-응답하기를-기다린다-이때-서버는-syn_received상태가-된다">ACK패킷으로 응답하기를 기다린다. 이때 서버는 SYN_RECEIVED상태가 된다.</h3>

<p><br /></p>
<h3 id="3-클라이언트는-서버에게-ack를-보내고-이후-서버와-연결이-이루어지고-데이터가-오가게된다">3. 클라이언트는 서버에게 ACK를 보내고 이후 서버와 연결이 이루어지고 데이터가 오가게된다.</h3>
<h3 id="이때-서버의-상태는-established상태이다">이때 서버의 상태는 established상태이다</h3>

<p><br />
<br /></p>

<h2 id="4-way-handshake란">4-way-handshake란</h2>
<hr />

<h3 id="세션을-종료하기-위해-수행되는-절차">세션을 종료하기 위해 수행되는 절차</h3>

<p><br /></p>
<h2 id="순서-1">순서</h2>
<h3 id="1-client---server-fin">1. Client -&gt; Server FIN</h3>
<h3 id="2-server---client-ack">2. Server -&gt; Client ACK</h3>
<h3 id="3-server---client-fin">3. Server -&gt; Client FIN</h3>
<h3 id="4-client---server-ack">4. Client -&gt; Server ACK</h3>

<p><br />
<img src="https://user-images.githubusercontent.com/37110261/82874609-2a6b0900-9f71-11ea-9c48-5b5da1b1d5b1.png" alt="4way" /></p>

<p><br /></p>
<h2 id="4-way-handshake-과정">4-way-handshake 과정</h2>
<hr />

<h3 id="1-클라이언트가-연결을-종료하겠다는-fin플래그를-전송한다">1. 클라이언트가 연결을 종료하겠다는 FIN플래그를 전송한다.</h3>
<h3 id="2-서버는-일단-알겠다는-ack를-보내고-자신의-통신이-끝날때까지-기다리는데-이-상태를-time_wait라고-한다">2. 서버는 일단 알겠다는 ACK를 보내고 자신의 통신이 끝날때까지 기다리는데 이 상태를 TIME_WAIT라고 한다</h3>
<h3 id="3-서버가-클라이언트와의-통신이-끝났으면-연결이-종료됬다고-클라이언트에게-fin플래그를-보낸다">3. 서버가 클라이언트와의 통신이 끝났으면 연결이 종료됬다고 클라이언트에게 FIN플래그를 보낸다.</h3>
<h3 id="4-클라이언트는-확인-했다는-ack를-서버로-보낸다">4. 클라이언트는 확인 했다는 ACK를 서버로 보낸다.</h3>

<blockquote>
  <p>만약 Server에서 FIN을 전송하기 전에 전송한 패킷이 여러가지 이유로 FIN패킷보다 늦게 도착한다면 
Client에서 세션을 종료시킨 뒤에 뒤늦게 도착하는 패킷이 있다면 이 패킷은 drop되고 데이터는 유실 될 것이다
이러한 일에 대비하여 Client는 Server로부터 FIN을 수신하더라도 일정시간(default 240초)동안 세션을 
남겨놓고 남은 패킷이 도착하기를 기다리는데 이 과정을 TIME_WAIT라고 한다.</p>
</blockquote>

<p><br /></p>

<h2 id="tcp-flags-종류-정리">TCP flags 종류 정리</h2>
<h3 id="syn--연결-요청-플래그">SYN -연결 요청 플래그</h3>
<blockquote>
  <p>통신 시작 시 세션을 연결하기 위한 플래그</p>
</blockquote>

<p><br /></p>

<h3 id="ack--응답-플래그">ACK -응답 플래그</h3>
<blockquote>
  <p>송신 측으로부터 패킷을 잘 받았다는 것을 알려주기 위한 플래그</p>
</blockquote>

<p><br /></p>

<h3 id="fin---연결-종료-플래그">FIN - 연결 종료 플래그</h3>
<blockquote>
  <p>더 이상 전송할 데이터가 없고 세션 연결을 종료시키겠다는 플래그</p>
</blockquote>

<p><br /></p>

<h3 id="rstreset---연결-재설정-플래그">RST(reset) - 연결 재설정 플래그</h3>
<blockquote>
  <p>비정상적인 세션을 끊기위해 연결을 재설정 하는 과정</p>
</blockquote>

<p><br /></p>

<h3 id="pshpush---넣기">PSH(push) - 넣기</h3>
<blockquote>
  <p>버퍼가 채워지기를 기다리지 않고 받는 즉시 전달한다.
버퍼링 없이 7Layer의 응용프로그램에게 바로 전달하는 플래그</p>
</blockquote>

<p><br /></p>

<h3 id="urgurgent---긴급-데이터-플래그">URG(urgent) - 긴급 데이터 플래그</h3>
<blockquote>
  <p>긴급한 데이터의 우선순위를 다른 데이터의 우선순위보다 높혀 긴급하게 전달하는 플래그</p>
</blockquote>
:ET