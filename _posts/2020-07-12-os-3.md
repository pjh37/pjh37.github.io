---
layout: post
title:  " 가상메모리, 물리메모리"
date:   2020-07-12
desc: "가상메모리, 물리메모리"
keywords: "os,c"
categories: [Os]
tags: [Os]
icon: icon-html
---

가상메모리
-----

> 다중 프로그래밍을 실현하기 위해서는 많은 프로세스들을 동시에 메모리에 올려두어야 한다
> 가상 메모리는 프로세스 전체가 메모리에 올라오지 않더라도 실행가능하도록 하는 기법이며
> 프로그램이 물리 메모리보다 커도 된다는 장점이 있다.

### 가상메모리 : 프로그램실행에 필요한 메모리 용량 전체를 할당받는게 아니라, 실행에 필요한
### 최소한의 메모리를 할당받아 ram에서 사용하고 나머지는 하드디스크에 저장하는 것 이다.

<br/>

## 가상 주소 공간
+ ### 한 프로세스가 메모리에 저장되는 논리적인 모습을 가상메모리에 구현한 공간이다. 프로세스
### 가 요구하는 메모리 공간을 가상메모리에 제공함으로서 현재 직접적으로 필요치 않은 메모리  
### 공간은 실제 물리 메모리에 올리지 않는 것으로 물리 메모리를 절약할 수 있다.

+ ### 예시로 한 프로그램이 실행되며 논리 메모리로 100kb가 요구 되었고 실행에 필요한 메모리  
### 공간합이 40kb라면, 실제 물리 메모리에는 40kb만 올라가고 나머지 60kb만큼은 필요시에  
### 물리메모리에 요구한다.

<br/>

## 프로세스간 페이지 공유
+ ### 시스템 라이브러리는 여러 프로세스들이 물리 메모리 페이지에두고 프로세스사이에 공유한다.
+ ### fork()를 통한 프로세스 생성 과정에서 페이지들이 공유되는 것을 가능하게 한다.

<br/>

## 요구 페이징
### 프로그램 실행 시작시에 프로그램 전체를 디스크에서 물리메모리에 적재하는 대신, 초기에
### 필요한 것들만 적재하는 전략을 요구페이징 이라 하며,요구 페이징을 사용하는 가상 메모리
### 에서는 실행과정에서 필요한 페이지들이 적재된다. 한 번도 접근되지 않은 페이지는 
### 물리 메모리에 적재되지 않는다

<br/>

## 메모리 관리
-----

<br/>

### 각각의 프로세스는 독립된 메모리 공간을 갖고, 운영체제 혹은 다른 프로세스의 메모리 공간에
### 접근 할 수 없는 제한이 있다. 운영체제만이 운영체제 메모리 영역과 사용자 메모리 영역의
### 접근에 제약 받지 않는다.

<br/>

## 단편화
### 프로세스들이 메모리에 적재되고 제거되는 일이 반복되다 보면 프로세스들이 차지 하는 메모리
### 틈 사이에 사용하지 못할 만큼의 작은 자유공간들이 늘어나게 되는데 이것이 단편화다

<br/>

+ ### 외부 단편화 : 메모리 공간 중 사용하지 못하게 되는 일부분. 물리 메모리에서 사이사이에 
### 남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 분산되어 있을때 발생

+ ### 내부 단편화 : 프로세스가 사용하는 메모리 공간에 포함된 남는 부분을 내부 단편화라 한다.

<br/>



## Paging(페이징)
### 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리
### 방법이다. 외부 단편화와 압축 작업을 해소하기 위해 생긴 방법으로 다음과 같이 나눈다.
> 물리 메모리 -> Frame이라는 고정크기로 분리  
> 논리 메모리 -> page라 불리는 고정크기 블록



### 페이징 기법을을 사용함으로써 논리 메모리를 물리 메모리에 저장될 때, 연속되어 저장될
### 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치됨으로서 외부 단편화를 해결할 수
### 있는 장점이 있다.

<br/>

### 하나의 프로세스가 사용하는 공간은 논리 메모리에서 여러개의 페이지로 나뉘어서 관리되고
### 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 mapping되어 저장된다고 볼 수있다.

> 단점 : 고정된 페이지이기 때문에 내부 단편화가 발생한다. 예를 들어 페이지의 크기가 1024b 이고  
프로세스A가 3123b의 메모리를 요구한다면 3개의 페이지 프레임에다가 51b가 남기 때문에 결과적으로  
4번째 페이지가 필요하며 이 4번째 페이지는 973b의 내부 단편화가 발생하게 된다.

<br/>

## Segmentation(세그멘테이션)
### 페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적
### 단위인 세그먼트(Segment)로 분할 하여 사용자가 두개의 주소로 지정(세그먼트 번호 + 변위)
### 세그먼트 테이블에는 각 세그먼트의 기준 (세그먼트의 시작 물리 주소)와 세그먼트 길이를 저장

> 단점 : 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되면, 자유 공간들이  
많은 수의 조각들로 나뉘어 외부 단편화가 발생한다.

<br/>


## 페이지 교체 알고리즘

### FIFO 페이지 교체
### first in first out으로 먼저 물리 메모리에 들어온 페이지 순서대로 페이지 교체 시점에 나가게 된다.

<br/>

### LRU페이지 교체
> LRU : Least Recently Used

### 최적 알고리즘의 근사 알고리즘으로 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다.
### FIFO보단 우수하지만 OPT보단 못하다.

<br/>

### LFU
> LFU : Least Frequently Used

### 참조 횟수가 가장 적은 페이지를 교체하는 방법이다. 활발하게 사용되는 페이지는 참조 횟수가
### 많아질 거라는 가정에서 만들어진 알고리즘이다.

물리메모리
-----