I"*<h2 id="가상메모리">가상메모리</h2>

<blockquote>
  <p>다중 프로그래밍을 실현하기 위해서는 많은 프로세스들을 동시에 메모리에 올려두어야 한다
가상 메모리는 프로세스 전체가 메모리에 올라오지 않더라도 실행가능하도록 하는 기법이며
프로그램이 물리 메모리보다 커도 된다는 장점이 있다.</p>
</blockquote>

<h3 id="가상메모리--프로그램실행에-필요한-메모리-용량-전체를-할당받는게-아니라-실행에-필요한">가상메모리 : 프로그램실행에 필요한 메모리 용량 전체를 할당받는게 아니라, 실행에 필요한</h3>
<h3 id="최소한의-메모리를-할당받아-ram에서-사용하고-나머지는-하드디스크에-저장하는-것-이다">최소한의 메모리를 할당받아 ram에서 사용하고 나머지는 하드디스크에 저장하는 것 이다.</h3>

<p><br /></p>

<h2 id="가상-주소-공간">가상 주소 공간</h2>
<ul>
  <li>
    <h3 id="한-프로세스가-메모리에-저장되는-논리적인-모습을-가상메모리에-구현한-공간이다-프로세스">한 프로세스가 메모리에 저장되는 논리적인 모습을 가상메모리에 구현한 공간이다. 프로세스</h3>
    <h3 id="가-요구하는-메모리-공간을-가상메모리에-제공함으로서-현재-직접적으로-필요치-않은-메모리">가 요구하는 메모리 공간을 가상메모리에 제공함으로서 현재 직접적으로 필요치 않은 메모리</h3>
    <h3 id="공간은-실제-물리-메모리에-올리지-않는-것으로-물리-메모리를-절약할-수-있다">공간은 실제 물리 메모리에 올리지 않는 것으로 물리 메모리를 절약할 수 있다.</h3>
  </li>
  <li>
    <h3 id="예시로-한-프로그램이-실행되며-논리-메모리로-100kb가-요구-되었고-실행에-필요한-메모리">예시로 한 프로그램이 실행되며 논리 메모리로 100kb가 요구 되었고 실행에 필요한 메모리</h3>
    <h3 id="공간합이-40kb라면-실제-물리-메모리에는-40kb만-올라가고-나머지-60kb만큼은-필요시에">공간합이 40kb라면, 실제 물리 메모리에는 40kb만 올라가고 나머지 60kb만큼은 필요시에</h3>
    <h3 id="물리메모리에-요구한다">물리메모리에 요구한다.</h3>
  </li>
</ul>

<p><br /></p>

<h2 id="프로세스간-페이지-공유">프로세스간 페이지 공유</h2>
<ul>
  <li>
    <h3 id="시스템-라이브러리는-여러-프로세스들이-물리-메모리-페이지에두고-프로세스사이에-공유한다">시스템 라이브러리는 여러 프로세스들이 물리 메모리 페이지에두고 프로세스사이에 공유한다.</h3>
  </li>
  <li>
    <h3 id="fork를-통한-프로세스-생성-과정에서-페이지들이-공유되는-것을-가능하게-한다">fork()를 통한 프로세스 생성 과정에서 페이지들이 공유되는 것을 가능하게 한다.</h3>
  </li>
</ul>

<p><br /></p>

<h2 id="요구-페이징">요구 페이징</h2>
<h3 id="프로그램-실행-시작시에-프로그램-전체를-디스크에서-물리메모리에-적재하는-대신-초기에">프로그램 실행 시작시에 프로그램 전체를 디스크에서 물리메모리에 적재하는 대신, 초기에</h3>
<h3 id="필요한-것들만-적재하는-전략을-요구페이징-이라-하며요구-페이징을-사용하는-가상-메모리">필요한 것들만 적재하는 전략을 요구페이징 이라 하며,요구 페이징을 사용하는 가상 메모리</h3>
<h3 id="에서는-실행과정에서-필요한-페이지들이-적재된다-한-번도-접근되지-않은-페이지는">에서는 실행과정에서 필요한 페이지들이 적재된다. 한 번도 접근되지 않은 페이지는</h3>
<h3 id="물리-메모리에-적재되지-않는다">물리 메모리에 적재되지 않는다</h3>

<p><br /></p>

<h2 id="메모리-관리">메모리 관리</h2>
<hr />

<p><br /></p>

<h3 id="각각의-프로세스는-독립된-메모리-공간을-갖고-운영체제-혹은-다른-프로세스의-메모리-공간에">각각의 프로세스는 독립된 메모리 공간을 갖고, 운영체제 혹은 다른 프로세스의 메모리 공간에</h3>
<h3 id="접근-할-수-없는-제한이-있다-운영체제만이-운영체제-메모리-영역과-사용자-메모리-영역의">접근 할 수 없는 제한이 있다. 운영체제만이 운영체제 메모리 영역과 사용자 메모리 영역의</h3>
<h3 id="접근에-제약-받지-않는다">접근에 제약 받지 않는다.</h3>

<p><br /></p>

<h2 id="단편화">단편화</h2>
<h3 id="프로세스들이-메모리에-적재되고-제거되는-일이-반복되다-보면-프로세스들이-차지-하는-메모리">프로세스들이 메모리에 적재되고 제거되는 일이 반복되다 보면 프로세스들이 차지 하는 메모리</h3>
<h3 id="틈-사이에-사용하지-못할-만큼의-작은-자유공간들이-늘어나게-되는데-이것이-단편화다">틈 사이에 사용하지 못할 만큼의 작은 자유공간들이 늘어나게 되는데 이것이 단편화다</h3>

<p><br /></p>

<ul>
  <li>
    <h3 id="외부-단편화--메모리-공간-중-사용하지-못하게-되는-일부분-물리-메모리에서-사이사이에">외부 단편화 : 메모리 공간 중 사용하지 못하게 되는 일부분. 물리 메모리에서 사이사이에</h3>
    <h3 id="남는-공간들을-모두-합치면-충분한-공간이-되는-부분들이-분산되어-있을때-발생">남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 분산되어 있을때 발생</h3>
  </li>
  <li>
    <h3 id="내부-단편화--프로세스가-사용하는-메모리-공간에-포함된-남는-부분을-내부-단편화라-한다">내부 단편화 : 프로세스가 사용하는 메모리 공간에 포함된 남는 부분을 내부 단편화라 한다.</h3>
  </li>
</ul>

<p><br /></p>

<h2 id="paging페이징">Paging(페이징)</h2>
<h3 id="하나의-프로세스가-사용하는-메모리-공간이-연속적이어야-한다는-제약을-없애는-메모리-관리">하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리</h3>
<h3 id="방법이다-외부-단편화와-압축-작업을-해소하기-위해-생긴-방법으로-다음과-같이-나눈다">방법이다. 외부 단편화와 압축 작업을 해소하기 위해 생긴 방법으로 다음과 같이 나눈다.</h3>
<blockquote>
  <p>물리 메모리 -&gt; Frame이라는 고정크기로 분리<br />
논리 메모리 -&gt; page라 불리는 고정크기 블록</p>
</blockquote>

<h3 id="페이징-기법을을-사용함으로써-논리-메모리를-물리-메모리에-저장될-때-연속되어-저장될">페이징 기법을을 사용함으로써 논리 메모리를 물리 메모리에 저장될 때, 연속되어 저장될</h3>
<h3 id="필요가-없고-물리-메모리의-남는-프레임에-적절히-배치됨으로서-외부-단편화를-해결할-수">필요가 없고 물리 메모리의 남는 프레임에 적절히 배치됨으로서 외부 단편화를 해결할 수</h3>
<h3 id="있는-장점이-있다">있는 장점이 있다.</h3>

<p><br /></p>

<h3 id="하나의-프로세스가-사용하는-공간은-논리-메모리에서-여러개의-페이지로-나뉘어서-관리되고">하나의 프로세스가 사용하는 공간은 논리 메모리에서 여러개의 페이지로 나뉘어서 관리되고</h3>
<h3 id="개별-페이지는-순서에-상관없이-물리-메모리에-있는-프레임에-mapping되어-저장된다고-볼-수있다">개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 mapping되어 저장된다고 볼 수있다.</h3>

<blockquote>
  <p>단점 : 고정된 페이지이기 때문에 내부 단편화가 발생한다. 예를 들어 페이지의 크기가 1024b 이고<br />
프로세스A가 3123b의 메모리를 요구한다면 3개의 페이지 프레임에다가 51b가 남기 때문에 결과적으로<br />
4번째 페이지가 필요하며 이 4번째 페이지는 973b의 내부 단편화가 발생하게 된다.</p>
</blockquote>

<p><br /></p>

<h2 id="segmentation세그멘테이션">Segmentation(세그멘테이션)</h2>
<h3 id="페이징에서처럼-논리-메모리와-물리-메모리를-같은-크기의-블록이-아닌-서로-다른-크기의-논리적">페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적</h3>
<h3 id="단위인-세그먼트segment로-분할-하여-사용자가-두개의-주소로-지정세그먼트-번호--변위">단위인 세그먼트(Segment)로 분할 하여 사용자가 두개의 주소로 지정(세그먼트 번호 + 변위)</h3>
<h3 id="세그먼트-테이블에는-각-세그먼트의-기준-세그먼트의-시작-물리-주소와-세그먼트-길이를-저장">세그먼트 테이블에는 각 세그먼트의 기준 (세그먼트의 시작 물리 주소)와 세그먼트 길이를 저장</h3>

<blockquote>
  <p>단점 : 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되면, 자유 공간들이<br />
많은 수의 조각들로 나뉘어 외부 단편화가 발생한다.</p>
</blockquote>

<p><br /></p>

<h2 id="페이지-교체-알고리즘">페이지 교체 알고리즘</h2>

<h3 id="fifo-페이지-교체">FIFO 페이지 교체</h3>
<h3 id="first-in-first-out으로-먼저-물리-메모리에-들어온-페이지-순서대로-페이지-교체-시점에-나가게-된다">first in first out으로 먼저 물리 메모리에 들어온 페이지 순서대로 페이지 교체 시점에 나가게 된다.</h3>

<p><br /></p>

<h3 id="lru페이지-교체">LRU페이지 교체</h3>
<blockquote>
  <p>LRU : Least Recently Used</p>
</blockquote>

<h3 id="최적-알고리즘의-근사-알고리즘으로-가장-오랫동안-사용되지-않은-페이지를-선택하여-교체한다">최적 알고리즘의 근사 알고리즘으로 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다.</h3>
<h3 id="fifo보단-우수하지만-opt보단-못하다">FIFO보단 우수하지만 OPT보단 못하다.</h3>

<p><br /></p>

<h3 id="lfu">LFU</h3>
<blockquote>
  <p>LFU : Least Frequently Used</p>
</blockquote>

<h3 id="참조-횟수가-가장-적은-페이지를-교체하는-방법이다-활발하게-사용되는-페이지는-참조-횟수가">참조 횟수가 가장 적은 페이지를 교체하는 방법이다. 활발하게 사용되는 페이지는 참조 횟수가</h3>
<h3 id="많아질-거라는-가정에서-만들어진-알고리즘이다">많아질 거라는 가정에서 만들어진 알고리즘이다.</h3>

<h2 id="물리메모리">물리메모리</h2>
:ET