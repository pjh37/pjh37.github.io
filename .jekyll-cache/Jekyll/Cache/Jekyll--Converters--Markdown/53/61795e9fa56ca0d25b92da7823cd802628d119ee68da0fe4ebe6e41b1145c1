I"<h1 id="java-jvm">Java jvm</h1>

<h3 id="jvm은-java와-os사이에서-중개자-역할을-하며-java가-os에-구애받지-않고-재사용을-가능하게">jvm은 java와 os사이에서 중개자 역할을 하며 java가 os에 구애받지 않고 재사용을 가능하게</h3>
<h3 id="해준다-그리고-메모리관리-gc를-수행한다">해준다. 그리고 메모리관리, GC를 수행한다.</h3>
<h3 id="그리고-jvm은-스택기반이다">그리고 jvm은 스택기반이다.</h3>

<p><br /></p>

<h2 id="자바프로그램-실행과정">자바프로그램 실행과정</h2>
<blockquote>
  <ol>
    <li>프로그램이 실행되면 JVM은 OS로부터 이 프로그램이 필요로 하는 메모리를 할당 받는다.
JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.</li>
    <li>자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어 자바 바이트코드(.class)로 변환</li>
    <li>Class Loader를 통해 class파일들을 JVM으로 로딩한다.</li>
    <li>로딩된 class파일들은 Execution engine을 통해 해석된다.(로딩된 바이트 코드-&gt;바이너리 코드로 변경)</li>
    <li>해석된 바이트 코드는 Runtime Data Area에 배치되어 실질적인 수행이 이루어지게 된다.
이러한 실행 과정 속에서 JVM은 필요에 따라 Thread Synchronization과 GC같은 작업을 한다.</li>
  </ol>
</blockquote>

<p><br /></p>

<h2 id="jvm-구성">jvm 구성</h2>

<ol>
  <li>
    <h3 id="java-complier-java-소스-파일을-jvm이-해석할-수-있는-java-byte-codeclass파일">Java Complier: java 소스 파일을 jvm이 해석할 수 있는 Java Byte Code(.class파일)</h3>
    <p>로 변경한다. 일반적인 윈도우 프로그램에서는 컴파일이후 어셈블리 파일이 생성된다.</p>
  </li>
  <li>
    <h3 id="class-loader-jvm으로-class파일들을-load한다-loading된-클래스들은">Class Loader: JVM으로 .class파일들을 Load한다. Loading된 클래스들은</h3>
    <p>Runtime data area에 배치된다. 일반적인 윈도우 프로그램의 경우 Load는 os가 주도</p>
  </li>
  <li>
    <h3 id="execution-engine-loading된-클래스의-bytecode를-해석interpret한다-이-과정에서">Execution Engine: Loading된 클래스의 Bytecode를 해석(Interpret)한다. 이 과정에서</h3>
    <p>Bytecode가 Binary Code로 변경된다.</p>
  </li>
  <li>
    <h3 id="runtime-data-area-jvm이라는-프로그램이-os로부터-할당-받는-메모리-영역이다">Runtime Data Area: JVM이라는 프로그램이 OS로부터 할당 받는 메모리 영역이다.</h3>
  </li>
</ol>

<p><br /></p>

<h2 id="구성요소-세부설명">구성요소 세부설명</h2>
<h3 id="클래스-로더class-loader">클래스 로더(Class Loader)</h3>
<h3 id="3가지-역할-담당">3가지 역할 담당</h3>
<ul>
  <li>
    <h3 id="loading">Loading</h3>
  </li>
  <li>
    <h3 id="linking">Linking</h3>
  </li>
  <li>
    <h3 id="inititalzation">Inititalzation</h3>
  </li>
</ul>

<p><br /></p>

<ol>
  <li>
    <h3 id="loading-1">Loading</h3>
    <h3 id="클래스-로더는-class파일을-읽어-바이트-코드를-메소드-영역에-저장한다">클래스 로더는 .class파일을 읽어 바이트 코드를 메소드 영역에 저장한다.</h3>
    <h3 id="각-class파일은-jvm에-의해-메소드-영역에-다음의-정보를-저장한다">각 .class파일은 JVM에 의해 메소드 영역에 다음의 정보를 저장한다.</h3>
    <ul>
      <li>
        <h3 id="로드된-클래스를-비롯한-그의-부모-클래스의-정보">로드된 클래스를 비롯한 그의 부모 클래스의 정보</h3>
      </li>
      <li>
        <h3 id="class파일이-classinterfaceenum과-관련여부">class파일이 Class,Interface,Enum과 관련여부</h3>
      </li>
      <li>
        <h3 id="변수나-메소드의-정보등">변수나 메소드의 정보등</h3>
        <h3 id="class파일이-로딩된-후에는-jvm은-힙-메모리-영역에-이-파일이-나타내는-클래스-유형의-객체를">.class파일이 로딩된 후에는 JVM은 힙 메모리 영역에 이 파일이 나타내는 클래스 유형의 객체를</h3>
        <h3 id="생성한다-이-클래스-객체를-이용하면-클래스의-이름-및-부모-클래스-이름메소드변수-정보를">생성한다. 이 클래스 객체를 이용하면 클래스의 이름 및 부모 클래스 이름,메소드,변수 정보를</h3>
        <h3 id="보여줄-수-있다">보여줄 수 있다.</h3>
      </li>
    </ul>
  </li>
</ol>

<p><br /></p>

<ol>
  <li>
    <h3 id="linking-1">Linking</h3>
    <h3 id="verification증명-preparation준비-resolution-3가지를-수행한다">verification(증명), preparation(준비), resolution 3가지를 수행한다.</h3>
    <ul>
      <li>
        <h3 id="verification--class파일의-정확성을-보장한다-파일이-적절히-포맷되었는지유효한-컴파일러에-의해">Verification : .class파일의 정확성을 보장한다. 파일이 적절히 포맷되었는지,유효한 컴파일러에 의해</h3>
        <p>생성되었는지 확인, 검증 실패시 런타임 에러</p>
      </li>
      <li>
        <h3 id="preparation--jvm은-메모리를-기본-값으로-초기화-한-후-클래스-변수들을-위한-메모리를-할당한다">Preparation : JVM은 메모리를 기본 값으로 초기화 한 후, 클래스 변수들을 위한 메모리를 할당한다.</h3>
      </li>
      <li>
        <h3 id="resolution--symbolic-references-를-direct-references-로-바꾸는-프로세스">Resolution : symbolic references 를 direct references 로 바꾸는 프로세스.</h3>
      </li>
    </ul>
  </li>
</ol>

<p><br /></p>

<ol>
  <li>
    <h3 id="inititalzation-1">Inititalzation</h3>
    <h3 id="모든-정적-변수들이-정의된-값으로-초기화-된다">모든 정적 변수들이 정의된 값으로 초기화 된다.</h3>
  </li>
</ol>

<p><br /></p>

<h2 id="클래스로더는-3가지-종류가-있다">클래스로더는 3가지 종류가 있다.</h2>
<ul>
  <li>
    <h3 id="bootstrap-class-loader-">Bootstrap class Loader :</h3>
  </li>
</ul>

:ET