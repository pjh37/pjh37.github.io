---
layout: post
title:  " [MYSQL] 인덱스의 종류"
date:   2020-11-24
desc: "Join의 인덱스 사용"
keywords: "database"
categories: [Database]
tags: [Database]
icon: icon-html
---

<br/>

### 참조: Real MySQL(도서)

<br/>

HDD와 SSD,랜덤 IO/순차 IO
====

<br/>

## 인덱스의 종류를 살펴보기 전 HDD와 SSD,랜덤 IO/순차 IO에대해 간략하게 알아보자

<br/>

### 컴퓨터에서 CPU나 메모리같은 장치들은 대부분 전자식 장치이지만 디스크 드라이브는 기계식 장치다. 그래서 데이터베이스 서버에서 디스크 장치가 병목지점이 된다. 이러한 기계식 디스크 드라이브를 대체하기 위해 나온 것이 SSD이다.

<br/>

### SSD는 기존의 디스크 드라이브에서 데이터 저장용 플래터를 제거하고 대신 플래시 메모리를 장착하고 있다. 그래서 디스크 원판을 기계적으로 회전시킬 필요가 없으므로 빠르게 데이터를 읽고 쓸 수 있다. 그리고 플래시 메모리는 전원이 공급되지 않아도 데이터가 삭제 되지않는다

```
속도
CPU>RAM>SSD>HDD
```

<br/>

### 디스크의 헤더를 움직이지 않고 한번에 많은 데이터를 읽는 순차I/O에서는 SSD가 디스크 드라이브보다 조금 빠르거나 거의 비슷한 성능을 보이기도 한다. 하지만 SSD의 장점은 기존의 디스크 드라이브보다 랜덤I/O가 훨씬 빠르다는 것이다. 다만, 데이터베이스 서버에서 순차I/O작업의 비중은 적은 편이고 랜덤I/O를 통해 작은 데이터를 읽고 쓰는 작업이 대부분이므로 DBMS에서 HDD보다 SSD가 더 최적이라고 볼 수 있다.

<br/>

랜덤I/O,순차I/O
====

### 3개의 페이지(16KBx3)를 가져와야 한다고 가정해보자
### 순차I/O는 1번의 시스템 콜을 요청하지만 랜덤I/O는 3개의 페이지를 디스크에 기록하기위해 3번의 시스템 콜을 해야한다. 즉, 디스크에 기록해야 할 위치를 찾기 위해 순차I/O는 디스크의 헤드를 1번 움직였고, 랜덤I/O는 디스크 헤드를 3번 움직인 것이다. 디스크에 데이터를 읽고 쓰는 데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다. 결국 위와 같은 경우에 순차I/O는 랜덤I/O보다 3배 빠르다고 볼 수 있다. 즉, 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한번에 기록하느냐에 의해 결정 된다고 볼 수 있다. 그래서 여러 번 쓰기 또는 읽기를 요청하는 랜덤 I/O작업이 훨씬 작업의 부하가 커지는 것이다.

## 요약
+ ### n개의 페이지를 기록할때 순차I/O는 시스템콜 1번 랜덤I/O는 n번의 시스템콜 발생
+ ### 디스크에 기록해야 할 위치를 찾기 위해 순차I/O는 디스크의 헤드를 1번 움직였고, 랜덤I/O는 디스크 헤드를 n번 움직인 것이다.
+ ### 디스크에 데이터를 읽고 쓰는 데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다. 
+ ### 그러므로 여러 번 쓰기 또는 읽기를 요청하는 랜덤 I/O작업이 훨씬 작업의 부하가 커진다.


## 인덱스
### 인덱스란 지정한 컬럼을 기준으로 메모리영역에 일종의 목차를 만드는 것이다.

<br/>

## 인덱스의 종류
+ ### primary: 중복되지 않는 유일한 키
+ ### normal: 중복을 허용하는 인덱스
+ ### unique: 중복을 허용하지 않는 유일한 키
+ ### foreign: 다른 테이블과의 관계성을 부여하는 키


<br/>

### primary key
+ ### 테이블 전체를 통틀어 중복되지 않는 값을 지정해야한다.
+ ### 테이블마다 딱 하나의 primary key를 가질 수 있다.

<br/>

### unique key
+ ### 테이블 전체를 통틀어 중복되지 않는 값을 지정해야한다.
+ ### 여러개의 unique key를 지정할 수 있다.

<br/>

### normal key
+ ### 중복을 허용한다.
+ ### primary,unique보다 속도가 느리다.
+ ### 여러개의 키를 지정할 수 있다.

<br/>

### Foreign key
+ ### join등으로 다른 DB와 관계를 맺는 경우 다른 테이블의 pk를 참조하는 컬럼이다.
+ ### 논리적,물리적으로 다른 테이블과 연결을 맺는 경우를 말하며 제약조건으로 역할을 할 수 도 있다.
    + ### restrict: fk관계를 맺고 있는 데이터의 row의 변경,삭제를 막는다.
    + ### cascade: fk와 관계를 맺은 상대 pk를 직접 연결해서 삭제또는 변경시 상대 key값도 삭제,갱신 시킬 수 있다.
    