---
layout: post
title:  " [MYSQL] Where,Group By,Order By 절의 인덱스 사용"
date:   2020-11-22
desc: "Where,Group By,Order By 절의 인덱스 사용"
keywords: "database"
categories: [Database]
tags: [Database]
icon: icon-html
---

인덱스를 사용하기 위한 기본 규칙
====

<br/>

### where절이나 order by또는 group by가 인덱스를 사용하려면 기본적으로 인덱스된 컬럼의 값 자체를
### 변환하지 않고 그대로 사용한다는 조건을 만족해야 한다. 인덱스는 칼럼의 값을 아무런 변환 없이
### B-Tree에 정렬해서 저장한다. where,group by, order by에서도 원본값을 검색하거나 정렬할 때만
### B-Tree에 정렬된 인덱스를 이용한다.

<br/>

### 다음 예제의 where절과 같이 salary칼럼을 가공한후 다른 상수 값과 비교한다면 다음의 쿼리는 인덱스를 적절히 이용하지 못하게 된다.

``` sql
SELECT * FROM salaries WHERE salary*10>15000;
```

<br/>

### where절에 사용되는 비교 조건에서 연산자 양쪽의 두 비교 대상 값은 데이터 타입이 일치해야 한다. 

``` sql
create table tb_test (age VARCHAR(10),~~)
select * from tb_test where age=2
```
### 위와 같은 경우 인덱스 레인지 스캔이 아니라 인덱스 풀 스캔을 하게 된다. 그 이유는 age칼럼의 데이터 타입(VARCHAR)과
### 비교되는 값 2(INTEGER 타입)의 데이터 타입이 다르기 때문이다.

<br/>

## 여러 컬러으로 인덱스 구성시 기준
### 카디널리티(중복도)가 낮은->높은순으로 구성하는게 좋을까?
### 카디널리티(중복도)가 높은->낮은순으로 구성하는게 좋을까?

``` sql
CREATE TABLE `salaries` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `emp_no` int(11) NOT NULL,
  `salary` int(11) NOT NULL,
  `from_date` date NOT NULL,
  `to_date` date NOT NULL,
  `is_bonus` tinyint(1) unsigned zerofill DEFAULT NULL,
  `group_no` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

> 카디널리티 순서 group_no > from_date > to_date > is_bonus

<br/>

``` sql
CREATE INDEX IDX_SALARIES_INCREASE ON salaries 
(is_bonus, from_date, group_no);

CREATE INDEX IDX_SALARIES_DECREASE ON salaries 
(group_no, from_date, is_bonus);
```

### 첫 번째 인덱스는 is_bonus, from_date, group_no순으로 카디널리티가 낮은순에서 높은 순으로
### 두 번째 인덱스는 group_no, from_date, is_bonus순으로 카디널리티가 높은순에서 낮은 순으로

<br/>

### 여러 컬럼으로 인덱스를 잡는 경우 카디널리티가 높은순에서 낮은순으로(group_no, from_date, is_bonus)
### 구성하는게 성능이 더 뛰어나다.

<br/>

여러 컬럼으로 인덱스시 조건 누락
====

### 인덱스의 컬럼을 모두 사용해야만 인덱스가 사용되는 것은 아니다.
### 그렇다면 어떤것이 누락되도 되고, 누락되면 안되는것은 무엇일까?

``` sql
CREATE INDEX IDX_SALARIES_DECREASE ON salaries 
(group_no, from_date, is_bonus);
```
### 여기서 중간에 있는 from_date를 제외한 조회 쿼리와 가장 앞에 있는 group_no를 제외한 조회쿼리를 사용해보자

<br/>

``` sql
select * from salaries where group_no='abcefe' and is_bonus=true;
```
> 인덱스를 정상적으로 사용한다.

<br/>

``` sql
select * from salaries where from_date='2020-11-11' and is_bonus=true;
```
> 인덱스 사용 못함

## 중요!!
### 조회 쿼리 사용시 인덱스를 태우려면 최소한 첫번째 조건은 조회조건에 포함되어야 한다.
### 첫번째 인덱스 컬럼이 조회쿼리에 없으면 인덱스를 타지 않는다!!!!


<br/>

인덱스 조회시 주의 사항
====
+ ### between,like,<,> 등 범위 조건은 해당 컬럼은 인덱스를 사용하지만, 그 뒤 인덱스 컬럼들은 인덱스가 사용되지 않는다.
    + ### 예시로 group_no, from_date, is_bonus으로 인덱스가 잡혀있는데 쿼리를 다음과 같이 쓸 경우 is_bonus는 인덱스가 사용되지 않는다.
    ``` sql
    where group_no='123' and is_bounus=Y and from_date > 2020
    ```
+ ### =,in은 다음 컬럼도 인덱스를 사용한다.
    + ### in은 =를 여러번 실행시킨것이다.
    + ### in은 인자값으로 상수가 포함되면 상관없지만, 서브쿼리를 넣게되면 성능상 이슈가 발생한다.
    + ### in의 인자로 서브쿼리가 들어가면 서브쿼리의 외부가 먼저 실행되고, in은 체크 조건으로 실행되기 때문이다.
+ ### and연산자는 각 조건들이 읽어와야할 row수를 줄이는 역할을 하지만 or연산자는 비교해야할 row가 더 늘어나기 때문에 Full table scan이 발생할 확률이 더 높다.
+ ### 인덱스로 사용된 컬럼값 그대로 사용해야만 인덱스가 사용된다.
    + ### 인덱스는 가공된 데이터를 저장하고 있지 않다.
    + ### where salary*10>15000;은 인덱스를 사용못하지만 where salary>15000는 인덱스 사용가능
+ ### null값은 is null조건으로 인덱스 레인지 스캔이 가능하다.